{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\sinty\\\\OneDrive\\\\Documents\\\\ECE\\\\cours_ing4\\\\Git-OCRES\\\\PROJECT_WEB_OCRES\\\\frontend\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport AggregateError from 'aggregate-error';\nexport default async function pMap(iterable, mapper, {\n  concurrency = Number.POSITIVE_INFINITY,\n  stopOnError = true\n} = {}) {\n  return new Promise((resolve, reject_) => {\n    // eslint-disable-line promise/param-names\n    if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n      throw new TypeError(\"Expected `input` to be either an `Iterable` or `AsyncIterable`, got (\".concat(typeof iterable, \")\"));\n    }\n\n    if (typeof mapper !== 'function') {\n      throw new TypeError('Mapper function is required');\n    }\n\n    if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n      throw new TypeError(\"Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `\".concat(concurrency, \"` (\").concat(typeof concurrency, \")\"));\n    }\n\n    const result = [];\n    const errors = [];\n    const skippedIndexesMap = new Map();\n    let isRejected = false;\n    let isResolved = false;\n    let isIterableDone = false;\n    let resolvingCount = 0;\n    let currentIndex = 0;\n    const iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n    const reject = reason => {\n      isRejected = true;\n      isResolved = true;\n      reject_(reason);\n    };\n\n    const next = async () => {\n      if (isResolved) {\n        return;\n      }\n\n      const nextItem = await iterator.next();\n      const index = currentIndex;\n      currentIndex++; // Note: `iterator.next()` can be called many times in parallel.\n      // This can cause multiple calls to this `next()` function to\n      // receive a `nextItem` with `done === true`.\n      // The shutdown logic that rejects/resolves must be protected\n      // so it runs only one time as the `skippedIndex` logic is\n      // non-idempotent.\n\n      if (nextItem.done) {\n        isIterableDone = true;\n\n        if (resolvingCount === 0 && !isResolved) {\n          if (!stopOnError && errors.length > 0) {\n            reject(new AggregateError(errors));\n            return;\n          }\n\n          isResolved = true;\n\n          if (!skippedIndexesMap.size) {\n            resolve(result);\n            return;\n          }\n\n          const pureResult = []; // Support multiple `pMapSkip`'s.\n\n          for (const _ref of result.entries()) {\n            var _ref2 = _slicedToArray(_ref, 2);\n\n            const index = _ref2[0];\n            const value = _ref2[1];\n\n            if (skippedIndexesMap.get(index) === pMapSkip) {\n              continue;\n            }\n\n            pureResult.push(value);\n          }\n\n          resolve(pureResult);\n        }\n\n        return;\n      }\n\n      resolvingCount++; // Intentionally detached\n\n      (async () => {\n        try {\n          const element = await nextItem.value;\n\n          if (isResolved) {\n            return;\n          }\n\n          const value = await mapper(element, index); // Use Map to stage the index of the element.\n\n          if (value === pMapSkip) {\n            skippedIndexesMap.set(index, value);\n          }\n\n          result[index] = value;\n          resolvingCount--;\n          await next();\n        } catch (error) {\n          if (stopOnError) {\n            reject(error);\n          } else {\n            errors.push(error);\n            resolvingCount--; // In that case we can't really continue regardless of `stopOnError` state\n            // since an iterable is likely to continue throwing after it throws once.\n            // If we continue calling `next()` indefinitely we will likely end up\n            // in an infinite loop of failed iteration.\n\n            try {\n              await next();\n            } catch (error) {\n              reject(error);\n            }\n          }\n        }\n      })();\n    }; // Create the concurrent runners in a detached (non-awaited)\n    // promise. We need this so we can await the `next()` calls\n    // to stop creating runners before hitting the concurrency limit\n    // if the iterable has already been marked as done.\n    // NOTE: We *must* do this for async iterators otherwise we'll spin up\n    // infinite `next()` calls by default and never start the event loop.\n\n\n    (async () => {\n      for (let index = 0; index < concurrency; index++) {\n        try {\n          // eslint-disable-next-line no-await-in-loop\n          await next();\n        } catch (error) {\n          reject(error);\n          break;\n        }\n\n        if (isIterableDone || isRejected) {\n          break;\n        }\n      }\n    })();\n  });\n}\nexport const pMapSkip = Symbol('skip');","map":null,"metadata":{},"sourceType":"module"}