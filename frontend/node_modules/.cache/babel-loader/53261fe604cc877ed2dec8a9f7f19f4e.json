{"ast":null,"code":"/* eslint-disable */\n\n/*\n* DO NOT MODIFY, THIS IS AUTO GENERATED\n* Execute `npm run generate` to regenerate\n*/\nimport pMap from \"p-map\";\nimport NodeCache from \"node-cache\";\nimport PokeAPIOptions from \"./interfaces/PokeAPIOptions.js\";\nimport handleError from \"./utils/ErrorHandler.js\";\nimport getJSON from \"./utils/Getter.js\";\nexport default class Pokedex {\n  constructor(options) {\n    this.options = new PokeAPIOptions(options, new NodeCache());\n  }\n\n  async getResource(endpoint, callback) {\n    try {\n      if (!endpoint) {\n        throw new Error('Param \"endpoint\" is required needs to be a string or array of strings');\n      }\n\n      if (typeof endpoint === 'string') {\n        return getJSON(this.options, endpoint, callback);\n      } else if (typeof endpoint === 'object') {\n        const mapper = async endpoints => {\n          const queryRes = await getJSON(this.options, endpoints);\n          return queryRes;\n        }; // Fetch data asynchronously to be faster\n\n\n        const mappedResults = await pMap(endpoint, mapper, {\n          concurrency: 4\n        });\n\n        if (callback) {\n          callback(mappedResults);\n        }\n\n        return mappedResults;\n      } else {\n        throw new Error('Param \"endpoint\" needs to be a string or array of strings');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** @deprecated - will be removed on the next version. Use {@link getResource} instead */\n\n\n  async resource(endpoint, callback) {\n    try {\n      if (!endpoint) {\n        throw new Error('Param \"endpoint\" is required needs to be a string or array of strings');\n      }\n\n      if (typeof endpoint === 'string') {\n        return getJSON(this.options, endpoint, callback);\n      } else if (typeof endpoint === 'object') {\n        const mapper = async endpoints => {\n          const queryRes = await getJSON(this.options, endpoints);\n          return queryRes;\n        }; // Fetch data asynchronously to be faster\n\n\n        const mappedResults = await pMap(endpoint, mapper, {\n          concurrency: 4\n        });\n\n        if (callback) {\n          callback(mappedResults);\n        }\n\n        return mappedResults;\n      } else {\n        throw new Error('Param \"endpoint\" needs to be a string or array of strings');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerryByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerryFirmnessByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-firmness/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-firmness/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerryFlavorByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-flavor/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-flavor/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestTypeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"contest-type/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"contest-type/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestEffectById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"contest-effect/\").concat(id, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"contest-effect/\").concat(ids, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getSuperContestEffectById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"super-contest-effect/\").concat(id, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"super-contest-effect/\").concat(ids, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterMethodByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-method/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-method/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-condition/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-condition/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionValueByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-condition-value/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-condition-value/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionChainById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"evolution-chain/\").concat(id, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"evolution-chain/\").concat(ids, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionTriggerByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"evolution-trigger/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"evolution-trigger/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGenerationByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"generation/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"generation/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokedexByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokedex/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokedex/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"version/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"version/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionGroupByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"version-group/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"version-group/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemAttributeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-attribute/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-attribute/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemCategoryByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-category/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-category/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemFlingEffectByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-fling-effect/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-fling-effect/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemPocketByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-pocket/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-pocket/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMachineById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"machine/\").concat(id, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"machine/\").concat(ids, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveAilmentByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-ailment/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-ailment/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveBattleStyleByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-battle-style/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-battle-style/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveCategoryByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-category/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-category/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveDamageClassByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-damage-class/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-damage-class/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveLearnMethodByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-learn-method/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-learn-method/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveTargetByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-target/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-target/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"location/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"location/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationAreaByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"location-area/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"location-area/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPalParkAreaByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pal-park-area/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pal-park-area/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getRegionByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"region/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"region/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getAbilityByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"ability/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"ability/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getCharacteristicById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"characteristic/\").concat(id, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"characteristic/\").concat(ids, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEggGroupByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"egg-group/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"egg-group/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGenderByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"gender/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"gender/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGrowthRateByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"growth-rate/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"growth-rate/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getNatureByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"nature/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"nature/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokeathlonStatByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokeathlon-stat/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokeathlon-stat/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonColorByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-color/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-color/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonFormByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-form/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-form/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonHabitatByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-habitat/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-habitat/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonShapeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-shape/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-shape/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonSpeciesByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-species/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-species/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getStatByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"stat/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"stat/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getTypeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"type/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"type/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLanguageByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"language/\").concat(nameOrId, \"/\"), callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"language/\").concat(nameOrIds, \"/\"));\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerriesList(interval, callback) {\n    try {\n      let _this$options = this.options,\n          limit = _this$options.limit,\n          offset = _this$options.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerriesFirmnessList(interval, callback) {\n    try {\n      let _this$options2 = this.options,\n          limit = _this$options2.limit,\n          offset = _this$options2.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-firmness/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** @deprecated will be removed on a future version. Use {@link getBerriesFirmnessList} instead */\n\n\n  async getBerriesFirmnesssList(interval, callback) {\n    try {\n      let _this$options3 = this.options,\n          limit = _this$options3.limit,\n          offset = _this$options3.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-firmness/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerriesFlavorsList(interval, callback) {\n    try {\n      let _this$options4 = this.options,\n          limit = _this$options4.limit,\n          offset = _this$options4.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"berry-flavor/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestTypesList(interval, callback) {\n    try {\n      let _this$options5 = this.options,\n          limit = _this$options5.limit,\n          offset = _this$options5.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"contest-type/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestEffectsList(interval, callback) {\n    try {\n      let _this$options6 = this.options,\n          limit = _this$options6.limit,\n          offset = _this$options6.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"contest-effect/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getSuperContestEffectsList(interval, callback) {\n    try {\n      let _this$options7 = this.options,\n          limit = _this$options7.limit,\n          offset = _this$options7.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"super-contest-effect/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterMethodsList(interval, callback) {\n    try {\n      let _this$options8 = this.options,\n          limit = _this$options8.limit,\n          offset = _this$options8.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-method/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionsList(interval, callback) {\n    try {\n      let _this$options9 = this.options,\n          limit = _this$options9.limit,\n          offset = _this$options9.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-condition/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionValuesList(interval, callback) {\n    try {\n      let _this$options10 = this.options,\n          limit = _this$options10.limit,\n          offset = _this$options10.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"encounter-condition-value/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionChainsList(interval, callback) {\n    try {\n      let _this$options11 = this.options,\n          limit = _this$options11.limit,\n          offset = _this$options11.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"evolution-chain/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionTriggersList(interval, callback) {\n    try {\n      let _this$options12 = this.options,\n          limit = _this$options12.limit,\n          offset = _this$options12.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"evolution-trigger/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGenerationsList(interval, callback) {\n    try {\n      let _this$options13 = this.options,\n          limit = _this$options13.limit,\n          offset = _this$options13.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"generation/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** @deprecated will be removed on a future version. Use {@link getPokedexList} instead */\n\n\n  async getPokedexsList(interval, callback) {\n    try {\n      let _this$options14 = this.options,\n          limit = _this$options14.limit,\n          offset = _this$options14.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokedex/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokedexList(interval, callback) {\n    try {\n      let _this$options15 = this.options,\n          limit = _this$options15.limit,\n          offset = _this$options15.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokedex/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionsList(interval, callback) {\n    try {\n      let _this$options16 = this.options,\n          limit = _this$options16.limit,\n          offset = _this$options16.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"version/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionGroupsList(interval, callback) {\n    try {\n      let _this$options17 = this.options,\n          limit = _this$options17.limit,\n          offset = _this$options17.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"version-group/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemsList(interval, callback) {\n    try {\n      let _this$options18 = this.options,\n          limit = _this$options18.limit,\n          offset = _this$options18.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemAttributesList(interval, callback) {\n    try {\n      let _this$options19 = this.options,\n          limit = _this$options19.limit,\n          offset = _this$options19.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-attribute/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemCategoriesList(interval, callback) {\n    try {\n      let _this$options20 = this.options,\n          limit = _this$options20.limit,\n          offset = _this$options20.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-category/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemFlingEffectsList(interval, callback) {\n    try {\n      let _this$options21 = this.options,\n          limit = _this$options21.limit,\n          offset = _this$options21.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-fling-effect/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemPocketsList(interval, callback) {\n    try {\n      let _this$options22 = this.options,\n          limit = _this$options22.limit,\n          offset = _this$options22.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"item-pocket/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMachinesList(interval, callback) {\n    try {\n      let _this$options23 = this.options,\n          limit = _this$options23.limit,\n          offset = _this$options23.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"machine/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMovesList(interval, callback) {\n    try {\n      let _this$options24 = this.options,\n          limit = _this$options24.limit,\n          offset = _this$options24.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveAilmentsList(interval, callback) {\n    try {\n      let _this$options25 = this.options,\n          limit = _this$options25.limit,\n          offset = _this$options25.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-ailment/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveBattleStylesList(interval, callback) {\n    try {\n      let _this$options26 = this.options,\n          limit = _this$options26.limit,\n          offset = _this$options26.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-battle-style/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveCategoriesList(interval, callback) {\n    try {\n      let _this$options27 = this.options,\n          limit = _this$options27.limit,\n          offset = _this$options27.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-category/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveDamageClassesList(interval, callback) {\n    try {\n      let _this$options28 = this.options,\n          limit = _this$options28.limit,\n          offset = _this$options28.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-damage-class/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveLearnMethodsList(interval, callback) {\n    try {\n      let _this$options29 = this.options,\n          limit = _this$options29.limit,\n          offset = _this$options29.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-learn-method/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveTargetsList(interval, callback) {\n    try {\n      let _this$options30 = this.options,\n          limit = _this$options30.limit,\n          offset = _this$options30.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"move-target/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationsList(interval, callback) {\n    try {\n      let _this$options31 = this.options,\n          limit = _this$options31.limit,\n          offset = _this$options31.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"location/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationAreasList(interval, callback) {\n    try {\n      let _this$options32 = this.options,\n          limit = _this$options32.limit,\n          offset = _this$options32.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"location-area/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPalParkAreasList(interval, callback) {\n    try {\n      let _this$options33 = this.options,\n          limit = _this$options33.limit,\n          offset = _this$options33.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pal-park-area/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getRegionsList(interval, callback) {\n    try {\n      let _this$options34 = this.options,\n          limit = _this$options34.limit,\n          offset = _this$options34.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"region/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getAbilitiesList(interval, callback) {\n    try {\n      let _this$options35 = this.options,\n          limit = _this$options35.limit,\n          offset = _this$options35.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"ability/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getCharacteristicsList(interval, callback) {\n    try {\n      let _this$options36 = this.options,\n          limit = _this$options36.limit,\n          offset = _this$options36.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"characteristic/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEggGroupsList(interval, callback) {\n    try {\n      let _this$options37 = this.options,\n          limit = _this$options37.limit,\n          offset = _this$options37.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"egg-group/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGendersList(interval, callback) {\n    try {\n      let _this$options38 = this.options,\n          limit = _this$options38.limit,\n          offset = _this$options38.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"gender/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGrowthRatesList(interval, callback) {\n    try {\n      let _this$options39 = this.options,\n          limit = _this$options39.limit,\n          offset = _this$options39.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"growth-rate/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getNaturesList(interval, callback) {\n    try {\n      let _this$options40 = this.options,\n          limit = _this$options40.limit,\n          offset = _this$options40.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"nature/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokeathlonStatsList(interval, callback) {\n    try {\n      let _this$options41 = this.options,\n          limit = _this$options41.limit,\n          offset = _this$options41.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokeathlon-stat/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonsList(interval, callback) {\n    try {\n      let _this$options42 = this.options,\n          limit = _this$options42.limit,\n          offset = _this$options42.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonColorsList(interval, callback) {\n    try {\n      let _this$options43 = this.options,\n          limit = _this$options43.limit,\n          offset = _this$options43.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-color/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonFormsList(interval, callback) {\n    try {\n      let _this$options44 = this.options,\n          limit = _this$options44.limit,\n          offset = _this$options44.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-form/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonHabitatsList(interval, callback) {\n    try {\n      let _this$options45 = this.options,\n          limit = _this$options45.limit,\n          offset = _this$options45.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-habitat/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonShapesList(interval, callback) {\n    try {\n      let _this$options46 = this.options,\n          limit = _this$options46.limit,\n          offset = _this$options46.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-shape/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonSpeciesList(interval, callback) {\n    try {\n      let _this$options47 = this.options,\n          limit = _this$options47.limit,\n          offset = _this$options47.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"pokemon-species/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getStatsList(interval, callback) {\n    try {\n      let _this$options48 = this.options,\n          limit = _this$options48.limit,\n          offset = _this$options48.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"stat/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getTypesList(interval, callback) {\n    try {\n      let _this$options49 = this.options,\n          limit = _this$options49.limit,\n          offset = _this$options49.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"type/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLanguagesList(interval, callback) {\n    try {\n      let _this$options50 = this.options,\n          limit = _this$options50.limit,\n          offset = _this$options50.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"language/?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEndpointsList(interval, callback) {\n    try {\n      let _this$options51 = this.options,\n          limit = _this$options51.limit,\n          offset = _this$options51.offset;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, \"\".concat(this.options.protocol).concat(this.options.hostName).concat(this.options.versionPath, \"?limit=\").concat(limit, \"&offset=\").concat(offset), callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** Retrieve the configs used */\n\n\n  getConfig() {\n    return this.options;\n  }\n  /** Retuns the current number of entries in the cache */\n\n\n  getCachedItemsCount() {\n    return this.options.cache.stats.keys;\n  }\n  /** @deprecated use {@link getCachedItemsCount} */\n\n\n  cacheSize() {\n    return this.options.cache.stats.keys;\n  }\n  /** Deletes all keys in cache */\n\n\n  clearCache() {\n    this.options.cache.flushAll();\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}