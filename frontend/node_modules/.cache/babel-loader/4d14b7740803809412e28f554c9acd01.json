{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\sinty\\\\OneDrive\\\\Documents\\\\ECE\\\\cours_ing4\\\\Git-OCRES\\\\PROJECT_WEB_OCRES\\\\frontend\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toArray = require(\"C:\\\\Users\\\\sinty\\\\OneDrive\\\\Documents\\\\ECE\\\\cours_ing4\\\\Git-OCRES\\\\PROJECT_WEB_OCRES\\\\frontend\\\\node_modules\\\\@babel\\\\runtime/helpers/toArray\");\n\n/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function () {\n  var EventEmitter,\n      NodeCache,\n      clone,\n      splice = [].splice,\n      boundMethodCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new Error('Bound instance method accessed before binding');\n    }\n  },\n      indexOf = [].indexOf;\n\n  clone = require(\"clone\");\n  EventEmitter = require('events').EventEmitter; // generate superclass\n\n  module.exports = NodeCache = function () {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super(); // ## get\n        // get a cached key and change the stats\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key\n        // **Example:**\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this); // ## mget\n        // get multiple cached keys at once and change the stats\n        // **Parameters:**\n        // * `keys` ( String|Number[] ): an array of keys\n        // **Example:**\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this); // ## set\n        // set a cached key and change the stats\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n        // **Example:**\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this); // ## mset\n        // set multiple keys at once\n        // **Parameters:**\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n        // **Example:**\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this); // ## del\n        // remove keys\n        // **Parameters:**\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n        // **Return**\n        // ( Number ): Number of deleted keys\n        // **Example:**\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this); // ## take\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key\n        // **Example:**\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this); // ## ttl\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n        // **Return**\n        // ( Boolen ): key found and ttl set\n        // **Example:**\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this); // ## getTtl\n        // receive the ttl of a key.\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key to check the ttl value\n        // **Return**\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n        // **Example:**\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this); // ## keys\n        // list all keys within this cache\n        // **Return**\n        // ( Array ): An array of all keys\n        // **Example:**\n        //     _keys = myCache.keys()\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this); // ## has\n        // Check if a key is cached\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key to check the ttl value\n        // **Return**\n        // ( Boolean ): A boolean that indicates if the key is cached\n        // **Example:**\n        //     _exists = myCache.has('myKey')\n        //     # true\n\n        this.has = this.has.bind(this); // ## getStats\n        // get the stats\n        // **Parameters:**\n        // -\n        // **Return**\n        // ( Object ): Stats data\n        // **Example:**\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this); // ## flushAll\n        // flush the whole data and reset the stats\n        // **Example:**\n        //     myCache.flushAll()\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this); // ## flushStats\n        // flush the stats and reset all counters to 0\n        // **Example:**\n        //     myCache.flushStats()\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this); // ## close\n        // This will clear the interval timeout which is set on checkperiod option.\n        // **Example:**\n        //     myCache.close()\n\n        this.close = this.close.bind(this); // ## _checkData\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n\n        this._checkData = this._checkData.bind(this); // ## _check\n        // internal method the check the value. If it's not valid any more delete it\n\n        this._check = this._check.bind(this); // ## _isInvalidKey\n        // internal method to check if the type of a key is either `number` or `string`\n\n        this._isInvalidKey = this._isInvalidKey.bind(this); // ## _wrap\n        // internal method to wrap a value in an object with some metadata\n\n        this._wrap = this._wrap.bind(this); // ## _getValLength\n        // internal method to calculate the value length\n\n        this._getValLength = this._getValLength.bind(this); // ## _error\n        // internal method to handle an error message\n\n        this._error = this._error.bind(this); // ## _initErrors\n        // internal method to generate error message templates\n\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n\n        this._initErrors(); // container for cached data\n\n\n        this.data = {}; // module options\n\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options); // generate functions with callbacks (legacy)\n\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach(methodKey => {\n            var oldMethod; // reference real function\n\n            oldMethod = this[methodKey];\n\n            this[methodKey] = function (...args) {\n              var _ref, _ref2, _splice$call, _splice$call2;\n\n              var cb, err, ref, res;\n              ref = args, (_ref = ref, _ref2 = _toArray(_ref), args = _ref2.slice(0), _ref), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call); // return a callback if cb is defined and a function\n\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        } // statistics container\n\n\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        }; // pre allocate valid keytypes array\n\n        this.validKeyTypes = [\"string\", \"number\"]; // initalize checking period\n\n        this._checkData();\n\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n\n        boundMethodCheck(this, NodeCache); // handle invalid key types\n\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        } // get data and incremet stats\n\n\n        if (this.data[key] != null && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]); // return data\n\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n\n        boundMethodCheck(this, NodeCache); // convert a string to an array of one key\n\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        } // define return\n\n\n        oRet = {};\n\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i]; // handle invalid key types\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          } // get data and increment stats\n\n\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        } // return all found keys\n\n\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n\n        boundMethodCheck(this, NodeCache); // check if cache is overflowing\n\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        } // force the data to string\n\n\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        } // set default ttl if not passed\n\n\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        } // handle invalid key types\n\n\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        } // internal helper variables\n\n\n        existent = false; // remove existing data from stats\n\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        } // set the value\n\n\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value); // only add the keys and key-size if the key is new\n\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n\n        this.emit(\"set\", key, value); // return true\n\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n\n        boundMethodCheck(this, NodeCache); // check if cache is overflowing\n\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        } // loop over keyValueSet to validate key and ttl\n\n\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          var _keyValuePair = keyValuePair;\n          key = _keyValuePair.key;\n          val = _keyValuePair.val;\n          ttl = _keyValuePair.ttl;\n\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          } // handle invalid key types\n\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          var _keyValuePair2 = keyValuePair;\n          key = _keyValuePair2.key;\n          val = _keyValuePair2.val;\n          ttl = _keyValuePair2.ttl;\n          this.set(key, val, ttl);\n        }\n\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache); // convert keys to an array of itself\n\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n\n        delCount = 0;\n\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i]; // handle invalid key types\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          } // only delete if existent\n\n\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++; // delete the value\n\n            oldVal = this.data[key];\n            delete this.data[key]; // return true\n\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n\n        if (_ret != null) {\n          this.del(key);\n        }\n\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n\n        if (!key) {\n          return false;\n        } // handle invalid key types\n\n\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        } // check for existent data and update the ttl value\n\n\n        if (this.data[key] != null && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n\n        boundMethodCheck(this, NodeCache);\n\n        if (!key) {\n          return void 0;\n        } // handle invalid key types\n\n\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        } // check for existant data and update the ttl value\n\n\n        if (this.data[key] != null && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n\n        boundMethodCheck(this, NodeCache);\n        _exists = this.data[key] != null && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache); // parameter just for testing\n        // set data empty\n\n        this.data = {}; // reset stats\n\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        }; // reset check period\n\n        this._killCheckPeriod();\n\n        this._checkData(_startPeriod);\n\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache); // reset stats\n\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data; // run the housekeeping method\n\n        for (key in ref) {\n          value = ref[key];\n\n          this._check(key, value);\n        }\n\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n\n          if (this.checkTimeout != null && this.checkTimeout.unref != null) {\n            this.checkTimeout.unref();\n          }\n        }\n      } // ## _killCheckPeriod\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n\n\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n\n        boundMethodCheck(this, NodeCache);\n        _retval = true; // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n\n        if (!this.options.useClones) {\n          asClone = false;\n        } // define the time to live\n\n\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000; // use given ttl\n\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + ttl * ttlMultiplicator;\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + this.options.stdTTL * ttlMultiplicator;\n          }\n        } // return the wrapped value\n\n\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      } // ## _unwrap\n      // internal method to extract get the value out of the wrapped value\n\n\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n\n        return null;\n      } // ## _getKeyLength\n      // internal method the calculate the key length\n\n\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if (value != null && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache); // generate the error object\n\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data; // return the error object\n\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function (args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    }\n\n    ;\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n    return NodeCache;\n  }.call(this);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}